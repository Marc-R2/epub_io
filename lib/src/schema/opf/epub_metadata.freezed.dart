// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'epub_metadata.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$EpubMetadata {
  List<String> get titles => throw _privateConstructorUsedError;
  List<EpubMetadataCreator> get creators => throw _privateConstructorUsedError;
  List<String> get subjects => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  List<String> get publishers => throw _privateConstructorUsedError;
  List<EpubMetadataContributor> get contributors =>
      throw _privateConstructorUsedError;
  List<EpubMetadataDate> get dates => throw _privateConstructorUsedError;
  List<String> get types => throw _privateConstructorUsedError;
  List<String> get formats => throw _privateConstructorUsedError;
  List<EpubMetadataIdentifier> get identifiers =>
      throw _privateConstructorUsedError;
  List<String> get sources => throw _privateConstructorUsedError;
  List<String> get languages => throw _privateConstructorUsedError;
  List<String> get relations => throw _privateConstructorUsedError;
  List<String> get coverages => throw _privateConstructorUsedError;
  List<String> get rights => throw _privateConstructorUsedError;
  List<EpubMetadataMeta> get metaItems => throw _privateConstructorUsedError;
  String? get xmlnsDc => throw _privateConstructorUsedError;
  String? get xmlnsOpf => throw _privateConstructorUsedError;
  List<Link>? get links => throw _privateConstructorUsedError;

  /// Create a copy of EpubMetadata
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EpubMetadataCopyWith<EpubMetadata> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EpubMetadataCopyWith<$Res> {
  factory $EpubMetadataCopyWith(
          EpubMetadata value, $Res Function(EpubMetadata) then) =
      _$EpubMetadataCopyWithImpl<$Res, EpubMetadata>;
  @useResult
  $Res call(
      {List<String> titles,
      List<EpubMetadataCreator> creators,
      List<String> subjects,
      String? description,
      List<String> publishers,
      List<EpubMetadataContributor> contributors,
      List<EpubMetadataDate> dates,
      List<String> types,
      List<String> formats,
      List<EpubMetadataIdentifier> identifiers,
      List<String> sources,
      List<String> languages,
      List<String> relations,
      List<String> coverages,
      List<String> rights,
      List<EpubMetadataMeta> metaItems,
      String? xmlnsDc,
      String? xmlnsOpf,
      List<Link>? links});
}

/// @nodoc
class _$EpubMetadataCopyWithImpl<$Res, $Val extends EpubMetadata>
    implements $EpubMetadataCopyWith<$Res> {
  _$EpubMetadataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EpubMetadata
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? titles = null,
    Object? creators = null,
    Object? subjects = null,
    Object? description = freezed,
    Object? publishers = null,
    Object? contributors = null,
    Object? dates = null,
    Object? types = null,
    Object? formats = null,
    Object? identifiers = null,
    Object? sources = null,
    Object? languages = null,
    Object? relations = null,
    Object? coverages = null,
    Object? rights = null,
    Object? metaItems = null,
    Object? xmlnsDc = freezed,
    Object? xmlnsOpf = freezed,
    Object? links = freezed,
  }) {
    return _then(_value.copyWith(
      titles: null == titles
          ? _value.titles
          : titles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      creators: null == creators
          ? _value.creators
          : creators // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataCreator>,
      subjects: null == subjects
          ? _value.subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<String>,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      publishers: null == publishers
          ? _value.publishers
          : publishers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      contributors: null == contributors
          ? _value.contributors
          : contributors // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataContributor>,
      dates: null == dates
          ? _value.dates
          : dates // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataDate>,
      types: null == types
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<String>,
      formats: null == formats
          ? _value.formats
          : formats // ignore: cast_nullable_to_non_nullable
              as List<String>,
      identifiers: null == identifiers
          ? _value.identifiers
          : identifiers // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataIdentifier>,
      sources: null == sources
          ? _value.sources
          : sources // ignore: cast_nullable_to_non_nullable
              as List<String>,
      languages: null == languages
          ? _value.languages
          : languages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      relations: null == relations
          ? _value.relations
          : relations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      coverages: null == coverages
          ? _value.coverages
          : coverages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      rights: null == rights
          ? _value.rights
          : rights // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metaItems: null == metaItems
          ? _value.metaItems
          : metaItems // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataMeta>,
      xmlnsDc: freezed == xmlnsDc
          ? _value.xmlnsDc
          : xmlnsDc // ignore: cast_nullable_to_non_nullable
              as String?,
      xmlnsOpf: freezed == xmlnsOpf
          ? _value.xmlnsOpf
          : xmlnsOpf // ignore: cast_nullable_to_non_nullable
              as String?,
      links: freezed == links
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as List<Link>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EpubMetadataImplCopyWith<$Res>
    implements $EpubMetadataCopyWith<$Res> {
  factory _$$EpubMetadataImplCopyWith(
          _$EpubMetadataImpl value, $Res Function(_$EpubMetadataImpl) then) =
      __$$EpubMetadataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<String> titles,
      List<EpubMetadataCreator> creators,
      List<String> subjects,
      String? description,
      List<String> publishers,
      List<EpubMetadataContributor> contributors,
      List<EpubMetadataDate> dates,
      List<String> types,
      List<String> formats,
      List<EpubMetadataIdentifier> identifiers,
      List<String> sources,
      List<String> languages,
      List<String> relations,
      List<String> coverages,
      List<String> rights,
      List<EpubMetadataMeta> metaItems,
      String? xmlnsDc,
      String? xmlnsOpf,
      List<Link>? links});
}

/// @nodoc
class __$$EpubMetadataImplCopyWithImpl<$Res>
    extends _$EpubMetadataCopyWithImpl<$Res, _$EpubMetadataImpl>
    implements _$$EpubMetadataImplCopyWith<$Res> {
  __$$EpubMetadataImplCopyWithImpl(
      _$EpubMetadataImpl _value, $Res Function(_$EpubMetadataImpl) _then)
      : super(_value, _then);

  /// Create a copy of EpubMetadata
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? titles = null,
    Object? creators = null,
    Object? subjects = null,
    Object? description = freezed,
    Object? publishers = null,
    Object? contributors = null,
    Object? dates = null,
    Object? types = null,
    Object? formats = null,
    Object? identifiers = null,
    Object? sources = null,
    Object? languages = null,
    Object? relations = null,
    Object? coverages = null,
    Object? rights = null,
    Object? metaItems = null,
    Object? xmlnsDc = freezed,
    Object? xmlnsOpf = freezed,
    Object? links = freezed,
  }) {
    return _then(_$EpubMetadataImpl(
      titles: null == titles
          ? _value._titles
          : titles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      creators: null == creators
          ? _value._creators
          : creators // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataCreator>,
      subjects: null == subjects
          ? _value._subjects
          : subjects // ignore: cast_nullable_to_non_nullable
              as List<String>,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      publishers: null == publishers
          ? _value._publishers
          : publishers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      contributors: null == contributors
          ? _value._contributors
          : contributors // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataContributor>,
      dates: null == dates
          ? _value._dates
          : dates // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataDate>,
      types: null == types
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<String>,
      formats: null == formats
          ? _value._formats
          : formats // ignore: cast_nullable_to_non_nullable
              as List<String>,
      identifiers: null == identifiers
          ? _value._identifiers
          : identifiers // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataIdentifier>,
      sources: null == sources
          ? _value._sources
          : sources // ignore: cast_nullable_to_non_nullable
              as List<String>,
      languages: null == languages
          ? _value._languages
          : languages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      relations: null == relations
          ? _value._relations
          : relations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      coverages: null == coverages
          ? _value._coverages
          : coverages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      rights: null == rights
          ? _value._rights
          : rights // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metaItems: null == metaItems
          ? _value._metaItems
          : metaItems // ignore: cast_nullable_to_non_nullable
              as List<EpubMetadataMeta>,
      xmlnsDc: freezed == xmlnsDc
          ? _value.xmlnsDc
          : xmlnsDc // ignore: cast_nullable_to_non_nullable
              as String?,
      xmlnsOpf: freezed == xmlnsOpf
          ? _value.xmlnsOpf
          : xmlnsOpf // ignore: cast_nullable_to_non_nullable
              as String?,
      links: freezed == links
          ? _value._links
          : links // ignore: cast_nullable_to_non_nullable
              as List<Link>?,
    ));
  }
}

/// @nodoc

class _$EpubMetadataImpl implements _EpubMetadata {
  const _$EpubMetadataImpl(
      {final List<String> titles = const <String>[],
      final List<EpubMetadataCreator> creators = const <EpubMetadataCreator>[],
      final List<String> subjects = const <String>[],
      this.description,
      final List<String> publishers = const <String>[],
      final List<EpubMetadataContributor> contributors =
          const <EpubMetadataContributor>[],
      final List<EpubMetadataDate> dates = const <EpubMetadataDate>[],
      final List<String> types = const <String>[],
      final List<String> formats = const <String>[],
      final List<EpubMetadataIdentifier> identifiers =
          const <EpubMetadataIdentifier>[],
      final List<String> sources = const <String>[],
      final List<String> languages = const <String>[],
      final List<String> relations = const <String>[],
      final List<String> coverages = const <String>[],
      final List<String> rights = const <String>[],
      final List<EpubMetadataMeta> metaItems = const <EpubMetadataMeta>[],
      this.xmlnsDc,
      this.xmlnsOpf,
      final List<Link>? links})
      : _titles = titles,
        _creators = creators,
        _subjects = subjects,
        _publishers = publishers,
        _contributors = contributors,
        _dates = dates,
        _types = types,
        _formats = formats,
        _identifiers = identifiers,
        _sources = sources,
        _languages = languages,
        _relations = relations,
        _coverages = coverages,
        _rights = rights,
        _metaItems = metaItems,
        _links = links;

  final List<String> _titles;
  @override
  @JsonKey()
  List<String> get titles {
    if (_titles is EqualUnmodifiableListView) return _titles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_titles);
  }

  final List<EpubMetadataCreator> _creators;
  @override
  @JsonKey()
  List<EpubMetadataCreator> get creators {
    if (_creators is EqualUnmodifiableListView) return _creators;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_creators);
  }

  final List<String> _subjects;
  @override
  @JsonKey()
  List<String> get subjects {
    if (_subjects is EqualUnmodifiableListView) return _subjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subjects);
  }

  @override
  final String? description;
  final List<String> _publishers;
  @override
  @JsonKey()
  List<String> get publishers {
    if (_publishers is EqualUnmodifiableListView) return _publishers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_publishers);
  }

  final List<EpubMetadataContributor> _contributors;
  @override
  @JsonKey()
  List<EpubMetadataContributor> get contributors {
    if (_contributors is EqualUnmodifiableListView) return _contributors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_contributors);
  }

  final List<EpubMetadataDate> _dates;
  @override
  @JsonKey()
  List<EpubMetadataDate> get dates {
    if (_dates is EqualUnmodifiableListView) return _dates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dates);
  }

  final List<String> _types;
  @override
  @JsonKey()
  List<String> get types {
    if (_types is EqualUnmodifiableListView) return _types;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  final List<String> _formats;
  @override
  @JsonKey()
  List<String> get formats {
    if (_formats is EqualUnmodifiableListView) return _formats;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_formats);
  }

  final List<EpubMetadataIdentifier> _identifiers;
  @override
  @JsonKey()
  List<EpubMetadataIdentifier> get identifiers {
    if (_identifiers is EqualUnmodifiableListView) return _identifiers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_identifiers);
  }

  final List<String> _sources;
  @override
  @JsonKey()
  List<String> get sources {
    if (_sources is EqualUnmodifiableListView) return _sources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sources);
  }

  final List<String> _languages;
  @override
  @JsonKey()
  List<String> get languages {
    if (_languages is EqualUnmodifiableListView) return _languages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_languages);
  }

  final List<String> _relations;
  @override
  @JsonKey()
  List<String> get relations {
    if (_relations is EqualUnmodifiableListView) return _relations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_relations);
  }

  final List<String> _coverages;
  @override
  @JsonKey()
  List<String> get coverages {
    if (_coverages is EqualUnmodifiableListView) return _coverages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_coverages);
  }

  final List<String> _rights;
  @override
  @JsonKey()
  List<String> get rights {
    if (_rights is EqualUnmodifiableListView) return _rights;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_rights);
  }

  final List<EpubMetadataMeta> _metaItems;
  @override
  @JsonKey()
  List<EpubMetadataMeta> get metaItems {
    if (_metaItems is EqualUnmodifiableListView) return _metaItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_metaItems);
  }

  @override
  final String? xmlnsDc;
  @override
  final String? xmlnsOpf;
  final List<Link>? _links;
  @override
  List<Link>? get links {
    final value = _links;
    if (value == null) return null;
    if (_links is EqualUnmodifiableListView) return _links;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'EpubMetadata(titles: $titles, creators: $creators, subjects: $subjects, description: $description, publishers: $publishers, contributors: $contributors, dates: $dates, types: $types, formats: $formats, identifiers: $identifiers, sources: $sources, languages: $languages, relations: $relations, coverages: $coverages, rights: $rights, metaItems: $metaItems, xmlnsDc: $xmlnsDc, xmlnsOpf: $xmlnsOpf, links: $links)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EpubMetadataImpl &&
            const DeepCollectionEquality().equals(other._titles, _titles) &&
            const DeepCollectionEquality().equals(other._creators, _creators) &&
            const DeepCollectionEquality().equals(other._subjects, _subjects) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._publishers, _publishers) &&
            const DeepCollectionEquality()
                .equals(other._contributors, _contributors) &&
            const DeepCollectionEquality().equals(other._dates, _dates) &&
            const DeepCollectionEquality().equals(other._types, _types) &&
            const DeepCollectionEquality().equals(other._formats, _formats) &&
            const DeepCollectionEquality()
                .equals(other._identifiers, _identifiers) &&
            const DeepCollectionEquality().equals(other._sources, _sources) &&
            const DeepCollectionEquality()
                .equals(other._languages, _languages) &&
            const DeepCollectionEquality()
                .equals(other._relations, _relations) &&
            const DeepCollectionEquality()
                .equals(other._coverages, _coverages) &&
            const DeepCollectionEquality().equals(other._rights, _rights) &&
            const DeepCollectionEquality()
                .equals(other._metaItems, _metaItems) &&
            (identical(other.xmlnsDc, xmlnsDc) || other.xmlnsDc == xmlnsDc) &&
            (identical(other.xmlnsOpf, xmlnsOpf) ||
                other.xmlnsOpf == xmlnsOpf) &&
            const DeepCollectionEquality().equals(other._links, _links));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        const DeepCollectionEquality().hash(_titles),
        const DeepCollectionEquality().hash(_creators),
        const DeepCollectionEquality().hash(_subjects),
        description,
        const DeepCollectionEquality().hash(_publishers),
        const DeepCollectionEquality().hash(_contributors),
        const DeepCollectionEquality().hash(_dates),
        const DeepCollectionEquality().hash(_types),
        const DeepCollectionEquality().hash(_formats),
        const DeepCollectionEquality().hash(_identifiers),
        const DeepCollectionEquality().hash(_sources),
        const DeepCollectionEquality().hash(_languages),
        const DeepCollectionEquality().hash(_relations),
        const DeepCollectionEquality().hash(_coverages),
        const DeepCollectionEquality().hash(_rights),
        const DeepCollectionEquality().hash(_metaItems),
        xmlnsDc,
        xmlnsOpf,
        const DeepCollectionEquality().hash(_links)
      ]);

  /// Create a copy of EpubMetadata
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EpubMetadataImplCopyWith<_$EpubMetadataImpl> get copyWith =>
      __$$EpubMetadataImplCopyWithImpl<_$EpubMetadataImpl>(this, _$identity);
}

abstract class _EpubMetadata implements EpubMetadata {
  const factory _EpubMetadata(
      {final List<String> titles,
      final List<EpubMetadataCreator> creators,
      final List<String> subjects,
      final String? description,
      final List<String> publishers,
      final List<EpubMetadataContributor> contributors,
      final List<EpubMetadataDate> dates,
      final List<String> types,
      final List<String> formats,
      final List<EpubMetadataIdentifier> identifiers,
      final List<String> sources,
      final List<String> languages,
      final List<String> relations,
      final List<String> coverages,
      final List<String> rights,
      final List<EpubMetadataMeta> metaItems,
      final String? xmlnsDc,
      final String? xmlnsOpf,
      final List<Link>? links}) = _$EpubMetadataImpl;

  @override
  List<String> get titles;
  @override
  List<EpubMetadataCreator> get creators;
  @override
  List<String> get subjects;
  @override
  String? get description;
  @override
  List<String> get publishers;
  @override
  List<EpubMetadataContributor> get contributors;
  @override
  List<EpubMetadataDate> get dates;
  @override
  List<String> get types;
  @override
  List<String> get formats;
  @override
  List<EpubMetadataIdentifier> get identifiers;
  @override
  List<String> get sources;
  @override
  List<String> get languages;
  @override
  List<String> get relations;
  @override
  List<String> get coverages;
  @override
  List<String> get rights;
  @override
  List<EpubMetadataMeta> get metaItems;
  @override
  String? get xmlnsDc;
  @override
  String? get xmlnsOpf;
  @override
  List<Link>? get links;

  /// Create a copy of EpubMetadata
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EpubMetadataImplCopyWith<_$EpubMetadataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Link {
  String get href => throw _privateConstructorUsedError;
  String? get rel => throw _privateConstructorUsedError;
  String? get refines => throw _privateConstructorUsedError;

  /// Create a copy of Link
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LinkCopyWith<Link> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LinkCopyWith<$Res> {
  factory $LinkCopyWith(Link value, $Res Function(Link) then) =
      _$LinkCopyWithImpl<$Res, Link>;
  @useResult
  $Res call({String href, String? rel, String? refines});
}

/// @nodoc
class _$LinkCopyWithImpl<$Res, $Val extends Link>
    implements $LinkCopyWith<$Res> {
  _$LinkCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Link
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? href = null,
    Object? rel = freezed,
    Object? refines = freezed,
  }) {
    return _then(_value.copyWith(
      href: null == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String,
      rel: freezed == rel
          ? _value.rel
          : rel // ignore: cast_nullable_to_non_nullable
              as String?,
      refines: freezed == refines
          ? _value.refines
          : refines // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LinkImplCopyWith<$Res> implements $LinkCopyWith<$Res> {
  factory _$$LinkImplCopyWith(
          _$LinkImpl value, $Res Function(_$LinkImpl) then) =
      __$$LinkImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String href, String? rel, String? refines});
}

/// @nodoc
class __$$LinkImplCopyWithImpl<$Res>
    extends _$LinkCopyWithImpl<$Res, _$LinkImpl>
    implements _$$LinkImplCopyWith<$Res> {
  __$$LinkImplCopyWithImpl(_$LinkImpl _value, $Res Function(_$LinkImpl) _then)
      : super(_value, _then);

  /// Create a copy of Link
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? href = null,
    Object? rel = freezed,
    Object? refines = freezed,
  }) {
    return _then(_$LinkImpl(
      href: null == href
          ? _value.href
          : href // ignore: cast_nullable_to_non_nullable
              as String,
      rel: freezed == rel
          ? _value.rel
          : rel // ignore: cast_nullable_to_non_nullable
              as String?,
      refines: freezed == refines
          ? _value.refines
          : refines // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$LinkImpl implements _Link {
  const _$LinkImpl({required this.href, this.rel, this.refines});

  @override
  final String href;
  @override
  final String? rel;
  @override
  final String? refines;

  @override
  String toString() {
    return 'Link(href: $href, rel: $rel, refines: $refines)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LinkImpl &&
            (identical(other.href, href) || other.href == href) &&
            (identical(other.rel, rel) || other.rel == rel) &&
            (identical(other.refines, refines) || other.refines == refines));
  }

  @override
  int get hashCode => Object.hash(runtimeType, href, rel, refines);

  /// Create a copy of Link
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LinkImplCopyWith<_$LinkImpl> get copyWith =>
      __$$LinkImplCopyWithImpl<_$LinkImpl>(this, _$identity);
}

abstract class _Link implements Link {
  const factory _Link(
      {required final String href,
      final String? rel,
      final String? refines}) = _$LinkImpl;

  @override
  String get href;
  @override
  String? get rel;
  @override
  String? get refines;

  /// Create a copy of Link
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LinkImplCopyWith<_$LinkImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
